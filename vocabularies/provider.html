<<<<<<< HEAD
﻿<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://unpkg.com/lucide@latest"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vocabulary</title>
  <link rel="stylesheet" href="/elements/vocab-styling.css" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
</head>

<body>
  <div class="container">
    <div class="top">
      <button class="navbar1" id="backBtn" type="button">
        <i data-lucide="arrow-left"></i> Go back
      </button>
      <button class="navbar1" id="testBtn" type="button">Test</button>
    </div>

    <div id="words-list"></div>
  </div>

  <script>
    lucide.createIcons();
  </script>

  <script type="module">
    import { auth, db, ref, get, update, serverTimestamp } from "/elements/firebase.js";
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

    const listEl = document.getElementById("words-list");
    const backBtn = document.getElementById("backBtn");
    const testBtn = document.getElementById("testBtn");

    const params = new URLSearchParams(location.search);
    const typeRaw = (params.get("type") || params.get("source") || params.get("mode") || "").toLowerCase();
    const name = params.get("name") || params.get("id") || "";

    const type =
      typeRaw === "unit" || typeRaw === "unitwords" ? "unitwords" :
      typeRaw === "listening" || typeRaw === "listenings" || typeRaw === "listeningwords" ? "listeningwords" :
      "";


const safeKey = (s) => String(s || "").replace(/[^a-zA-Z0-9_-]/g, "_").slice(0, 120);
const progressBucketsFor = (t) => {
  const clean = t; // unitwords | listeningwords
  const legacy = (t === "unitwords" ? "unitswords" : "listeningswords");
  return Array.from(new Set([clean, legacy]));
};

async function touchProgress(uid, totalWords) {
  if (!uid || !type || !name) return;

  const buckets = progressBucketsFor(type);
  const modKey = safeKey(name);
  const now = Date.now();
  const nowISO = new Date().toISOString();

  // Read previous progress from the first existing bucket (if any)
  let prev = {};
  for (const b of buckets) {
    try {
      const s = await get(ref(db, `students/${uid}/progress/vocabularies/${b}/${modKey}`));
      if (s.exists()) { prev = s.val() || {}; break; }
    } catch {}
  }

  const openedAtMs = Number(prev.openedAtMs || now);
  const totalWordsVal = Number(prev.totalWords || totalWords || 0);

  // Write/update all buckets (clean + legacy)
  for (const b of buckets) {
    const progRef = ref(db, `students/${uid}/progress/vocabularies/${b}/${modKey}`);
    await update(progRef, {
      name,
      originalType: type,
      type: b,
      bucket: b,
      opened: true,
      openedAtMs,
      lastOpenedAtMs: now,
      lastOpenedISO: nowISO,
      totalWords: totalWordsVal,
      completed: !!prev.completed,
      updatedAtMs: typeof serverTimestamp === "function" ? serverTimestamp() : now,
    });
  }
}

async function touchListeningAccess(uid) {
  // Create students/{uid}/vocabularies/listeningwords/{module}/hasaccess=false on first open.
  if (!uid || type !== "listeningwords" || !name) return;

  const k = safeKey(name);
  const nodeRef = ref(db, `students/${uid}/vocabularies/listeningwords/${k}`);
  const now = Date.now();

  let existing = null;
  try {
    const s = await get(nodeRef);
    existing = s.exists() ? (s.val() || {}) : null;
  } catch {}

  const payload = { name, lastOpenedAtMs: now };
  if (!existing || typeof existing.hasaccess !== "boolean") {
    payload.hasaccess = false;
    payload.firstOpenedAtMs = now;
  }

  await update(nodeRef, payload);
}

function showText(msg) {
      listEl.innerHTML = "";
      const p = document.createElement("p");
      p.className = "yozuv";
      p.textContent = msg;
      listEl.appendChild(p);
    }

    function showLoading() {
      listEl.innerHTML = `
        <div class="cont-ani">
          <div class="ani-box">
            <img
              src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExeWt5YTFwYTh5bnIxcTB0aWZhOHBzeGU3dGlqanI4a3c3YXQ2ODJ0NiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/shy4aW0HlGtKLhvAXt/giphy.gif"
              alt="wait"
              class="gif-video"
            />
            <p class="yozuv">Loading...</p>
          </div>
        </div>
      `;
    }

    function renderWords(wordsObj) {
      listEl.innerHTML = "";

      const entries = Object.entries(wordsObj || {})
        .filter(([, v]) => v && typeof v === "object")
        .sort((a, b) => (Number(a[0]) || 0) - (Number(b[0]) || 0));

      if (!entries.length) { showText("No words inside this module."); return 0; }


      for (const [k, w] of entries) {
        const eng = w.eng ?? "";
        const transcription = w.transcription ?? "";
        const uzb = w.uzb ?? "";
        const rus = w.rus ?? "";

        const p = document.createElement("p");
        p.className = "yozuv";
        p.textContent = `${k}) ${eng} - ${transcription} - ${uzb} - ${rus}`;
        listEl.appendChild(p);
      }
          return entries.length;
    }

    function setupNav() {
      backBtn.addEventListener("click", () => {
        if (type === "unitwords") {
          location.href = "/vocabularies/units-menu.html";
          return;
        }
        if (type === "listeningwords") {
          location.href = "/vocabularies/listenings-menu.html";
          return;
        }
        history.back();
      });

      testBtn.addEventListener("click", () => {
        if (!type || !name) return;

        // Save context for test.js fallback
        try {
          localStorage.setItem("eduventure_vocab_context", JSON.stringify({ type, name }));
        } catch {}

        location.href = `/vocabularies/test.html?type=${encodeURIComponent(type)}&name=${encodeURIComponent(name)}`;
      });
    }

    async function load(uid) {
      if (!type || !name) {
        return showText("Missing URL params. Example: ?type=unitwords&name=unit1");
      }

      setupNav();

      const path = `vocabularies/${type}/${name}`;
      showLoading();

      const snap = await get(ref(db, path));
      if (!snap.exists()) return showText(`Not found: ${path}`);

      document.title = `${name} | Vocabulary`;
      const count = renderWords(snap.val());
      try { await touchProgress(uid, count); } catch (e) { console.warn('Progress write failed:', e); }
      try { await touchListeningAccess(uid); } catch (e) { console.warn('Listening access write failed:', e); }
    }

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        location.href = "/pages/auth/reg.html";
        return;
      }
      try {
        await load(user.uid);
      } catch (e) {
        console.error(e);
        showText("Failed to load words (check rules / connection). ");
      }
    });
  </script>
  <script src="/elements/UI.js"></script>
<script src="/sw.js"></script>
</body>
</html>
=======
﻿<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://unpkg.com/lucide@latest"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vocabulary</title>
  <link rel="stylesheet" href="/elements/vocab-styling.css" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
</head>

<body>
  <div class="container">
    <div class="top">
      <button class="navbar1" id="backBtn" type="button">
        <i data-lucide="arrow-left"></i> Go back
      </button>
      <button class="navbar1" id="testBtn" type="button">Test</button>
    </div>

    <div id="words-list"></div>
  </div>

  <script>
    lucide.createIcons();
  </script>

  <script type="module">
    import { auth, db, ref, get, update, serverTimestamp } from "/elements/firebase.js";
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

    const listEl = document.getElementById("words-list");
    const backBtn = document.getElementById("backBtn");
    const testBtn = document.getElementById("testBtn");

    const params = new URLSearchParams(location.search);
    const typeRaw = (params.get("type") || params.get("source") || params.get("mode") || "").toLowerCase();
    const name = params.get("name") || params.get("id") || "";

    const type =
      typeRaw === "unit" || typeRaw === "unitwords" ? "unitwords" :
      typeRaw === "listening" || typeRaw === "listenings" || typeRaw === "listeningwords" ? "listeningwords" :
      "";


const safeKey = (s) => String(s || "").replace(/[^a-zA-Z0-9_-]/g, "_").slice(0, 120);
const progressBucketsFor = (t) => {
  const clean = t; // unitwords | listeningwords
  const legacy = (t === "unitwords" ? "unitswords" : "listeningswords");
  return Array.from(new Set([clean, legacy]));
};

async function touchProgress(uid, totalWords) {
  if (!uid || !type || !name) return;

  const buckets = progressBucketsFor(type);
  const modKey = safeKey(name);
  const now = Date.now();
  const nowISO = new Date().toISOString();

  // Read previous progress from the first existing bucket (if any)
  let prev = {};
  for (const b of buckets) {
    try {
      const s = await get(ref(db, `students/${uid}/progress/vocabularies/${b}/${modKey}`));
      if (s.exists()) { prev = s.val() || {}; break; }
    } catch {}
  }

  const openedAtMs = Number(prev.openedAtMs || now);
  const totalWordsVal = Number(prev.totalWords || totalWords || 0);

  // Write/update all buckets (clean + legacy)
  for (const b of buckets) {
    const progRef = ref(db, `students/${uid}/progress/vocabularies/${b}/${modKey}`);
    await update(progRef, {
      name,
      originalType: type,
      type: b,
      bucket: b,
      opened: true,
      openedAtMs,
      lastOpenedAtMs: now,
      lastOpenedISO: nowISO,
      totalWords: totalWordsVal,
      completed: !!prev.completed,
      updatedAtMs: typeof serverTimestamp === "function" ? serverTimestamp() : now,
    });
  }
}

async function touchListeningAccess(uid) {
  // Create students/{uid}/vocabularies/listeningwords/{module}/hasaccess=false on first open.
  if (!uid || type !== "listeningwords" || !name) return;

  const k = safeKey(name);
  const nodeRef = ref(db, `students/${uid}/vocabularies/listeningwords/${k}`);
  const now = Date.now();

  let existing = null;
  try {
    const s = await get(nodeRef);
    existing = s.exists() ? (s.val() || {}) : null;
  } catch {}

  const payload = { name, lastOpenedAtMs: now };
  if (!existing || typeof existing.hasaccess !== "boolean") {
    payload.hasaccess = false;
    payload.firstOpenedAtMs = now;
  }

  await update(nodeRef, payload);
}

function showText(msg) {
      listEl.innerHTML = "";
      const p = document.createElement("p");
      p.className = "yozuv";
      p.textContent = msg;
      listEl.appendChild(p);
    }

    function showLoading() {
      listEl.innerHTML = `
        <div class="cont-ani">
          <div class="ani-box">
            <img
              src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExeWt5YTFwYTh5bnIxcTB0aWZhOHBzeGU3dGlqanI4a3c3YXQ2ODJ0NiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/shy4aW0HlGtKLhvAXt/giphy.gif"
              alt="wait"
              class="gif-video"
            />
            <p class="yozuv">Loading...</p>
          </div>
        </div>
      `;
    }

    function renderWords(wordsObj) {
      listEl.innerHTML = "";

      const entries = Object.entries(wordsObj || {})
        .filter(([, v]) => v && typeof v === "object")
        .sort((a, b) => (Number(a[0]) || 0) - (Number(b[0]) || 0));

      if (!entries.length) { showText("No words inside this module."); return 0; }


      for (const [k, w] of entries) {
        const eng = w.eng ?? "";
        const transcription = w.transcription ?? "";
        const uzb = w.uzb ?? "";
        const rus = w.rus ?? "";

        const p = document.createElement("p");
        p.className = "yozuv";
        p.textContent = `${k}) ${eng} - ${transcription} - ${uzb} - ${rus}`;
        listEl.appendChild(p);
      }
          return entries.length;
    }

    function setupNav() {
      backBtn.addEventListener("click", () => {
        if (type === "unitwords") {
          location.href = "/vocabularies/units-menu.html";
          return;
        }
        if (type === "listeningwords") {
          location.href = "/vocabularies/listenings-menu.html";
          return;
        }
        history.back();
      });

      testBtn.addEventListener("click", () => {
        if (!type || !name) return;

        // Save context for test.js fallback
        try {
          localStorage.setItem("eduventure_vocab_context", JSON.stringify({ type, name }));
        } catch {}

        location.href = `/vocabularies/test.html?type=${encodeURIComponent(type)}&name=${encodeURIComponent(name)}`;
      });
    }

    async function load(uid) {
      if (!type || !name) {
        return showText("Missing URL params. Example: ?type=unitwords&name=unit1");
      }

      setupNav();

      const path = `vocabularies/${type}/${name}`;
      showLoading();

      const snap = await get(ref(db, path));
      if (!snap.exists()) return showText(`Not found: ${path}`);

      document.title = `${name} | Vocabulary`;
      const count = renderWords(snap.val());
      try { await touchProgress(uid, count); } catch (e) { console.warn('Progress write failed:', e); }
      try { await touchListeningAccess(uid); } catch (e) { console.warn('Listening access write failed:', e); }
    }

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        location.href = "/pages/auth/reg.html";
        return;
      }
      try {
        await load(user.uid);
      } catch (e) {
        console.error(e);
        showText("Failed to load words (check rules / connection). ");
      }
    });
  </script>
  <script src="/elements/UI.js"></script>
<script src="/sw.js"></script>
</body>
</html>
>>>>>>> 5190efbbfc004e7f2b1521b7378bb9023f978c2c
